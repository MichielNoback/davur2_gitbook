# Exercise Solutions {#exercise-solutions}

```{r, include=FALSE}
options(digits = 3)
knitr::opts_knit$set(cache = TRUE,
                     tidy = TRUE,
                     tidy.opts = list(blank = FALSE, width.cutoff = 60))
```


## Introduction

Only solutions chunks are displayed here, not the output.

## `ggplot2`

```{r}
library(ggplot2)
library(tidyr)
```

### Global temperature

Load the data.

```{r}
temp_file <- "https://raw.githubusercontent.com/MichielNoback/datasets/master/global_temperature/annual.csv"
download.file(temp_file, destfile = "annual.csv")
global_temp <- read.table("annual.csv",
                          header = TRUE,
                          sep = ",")
```

#### Create a scatter-and-line-plot

```{r scatter-global-temp, fig.asp=0.7, out.width='80%', fig.align='center', fig.cap="Global temperature anomalies"}
ggplot(data = global_temp,
       mapping = aes(x = Year, y = Mean, color = Source)) +
    geom_point(size = 0.5) +
    geom_line() +
    geom_smooth(se = FALSE, method = "loess") +
    theme_bw()
```

#### Re-create the heatmap

```{r heatmap-global-temp, fig.asp=0.3, out.width='80%', fig.align='center', fig.cap="Global temperature anomalies"}
ggplot(data = global_temp[global_temp$Source == "GCAG", ],
       mapping = aes(x = Year, y = 1)) +
    geom_tile(aes(fill = Mean), colour = "white") + 
    scale_fill_gradient2(low = "blue", mid = "white", high = "red") +
    theme_bw() +
    theme(axis.text.y = element_blank(), axis.ticks.y = element_blank(), axis.title.y = element_blank())
```

Note: rescaling the temperature from 0 to 1 may yield even better results.

### Epilepsy drug trial

#### Load data

```{r results = 'hide'}
epilepsy_file <- "https://raw.githubusercontent.com/MichielNoback/datasets/master/epilepsy/epilepsy.csv"
epilepsy <- read.table(epilepsy_file,
                        header = TRUE,
                        sep = ",")
epilepsy$period <- factor(epilepsy$period, ordered=TRUE)
```

#### Reorganize the data

```{r results = 'hide'}
(epilepsy <- as_tibble(
    epilepsy[, c("subject","age","base","treatment","period","seizure.rate")]))
```

#### Create plots of seizure rates

**boxplot** 
I used the `color` aesthetic here:

```{r boxplot-seizure-rates, fig.asp=0.7, out.width='80%', fig.align='center', fig.cap="Seizure rates with color"}
ggplot(data = epilepsy,
       mapping = aes(x = period, y = seizure.rate, color = treatment)) +
    geom_boxplot()
```

This is the alternative with `facet_wrap()`

```{r boxplot-seizure-rates2, fig.asp=0.7, out.width='80%', fig.align='center', fig.cap="Seizure rates with facet wrap"}
ggplot(data = epilepsy,
       mapping = aes(x = period, y = seizure.rate)) +
    geom_boxplot() +
    facet_wrap(. ~ treatment)
```

**jitter plot**

Again, this could be done with color or facetting, but in this case `shape` is also an option (not shown). I used a little trick to separate the `period` for treated/untreated.

```{r boxplot-seizure-rates3, fig.asp=0.7, out.width='80%', fig.align='center', fig.cap="Seizure rates"}
tmp <- epilepsy
tmp$period <- as.integer(tmp$period)
tmp$period_offset <- ifelse(epilepsy$treatment == "placebo", tmp$period - 0.10, tmp$period + 0.10)
#tmp
ggplot(data = tmp,
       mapping = aes(x = period_offset, y = seizure.rate, color = treatment)) +
    geom_jitter(width = 0.05, alpha = 0.7) 
```

**overlay**

```{r boxplot-seizure-rates4, fig.asp=0.7, out.width='90%', fig.align='center', fig.cap="Seizure rates"}
ggplot(data = epilepsy,
       mapping = aes(x = period, y = seizure.rate, color = treatment)) +
    geom_boxplot(aes(fill = treatment), alpha = 0.2) +
    geom_jitter(data = tmp, aes(x = period_offset), width = 0.05, height = 0, alpha = 0.5, shape = 18, size = 2) +
    theme_bw()
```

Note that it would have been nicer to omit the outliers from the boxplot. This is your challenge.

There are many more variations possible! You should really explore some of these as practice.

#### A boxplot after correction

Correction:

```{r results = 'hide'}
epilepsy_corrected <- aggregate(
    seizure.rate ~ subject + age + base + treatment, 
    data = epilepsy, 
    FUN = sum)
epilepsy_corrected$seizure_rate_corrected <- epilepsy_corrected$seizure.rate - epilepsy_corrected$base
```

The plot:

```{r boxplot-seizure-rates5, fig.asp=0.7, out.width='80%', fig.align='center', fig.cap="Seizure rates after correction"}
ggplot(data = epilepsy_corrected,
       mapping = aes(x = treatment, y = seizure_rate_corrected)) +
    geom_boxplot()
```

#### Test for statistical significance

```{r}
placebo <- epilepsy_corrected$seizure_rate_corrected[epilepsy_corrected$treatment == "placebo"]
treated <- epilepsy_corrected$seizure_rate_corrected[epilepsy_corrected$treatment == "Progabide"]
t.test(x = placebo, y = treated)

##better:
t.test(seizure_rate_corrected ~ treatment, data = epilepsy_corrected)
```

Note: you should actually test for normality sing the `shapiro.test()` function before embarking on a t-test analysis:

```{r results = 'hide'}
shapiro.test(treated)
shapiro.test(placebo)
```

So this is not the correct test; you should use the Mann-Whitney U test.

```{r}
wilcox.test(seizure_rate_corrected ~ treatment, data = epilepsy_corrected)
```

### The dinos

#### export to csv

This exercise has no code. I exported the data and placed the csv files under `data/dinos/` of this repo.

#### clean up and load `codebook.csv`

Non-data lines were deleted. Lines 1-18 relate to skeleton data and 19-29 to footprint data. 

**1. Load the resulting file and assign it to variable `codebook`.**  

The separator is ": " but it is not possible to define multi-character separators in `read.table()`. For now, simply use ":".

```{r results = 'hide'}
codebook_file <- "data/dinos/codebook.csv"
codebook <- read.table(codebook_file, 
                      sep = ":",
                      stringsAsFactors = FALSE)
```

**2. Give the dataframe column names: `variable` and `description`.**

```{r results = 'hide'}
names(codebook) <- c('variable', 'description')
```


**3. Remove the leading space of the second column **

```{r results = 'hide'}
codebook$description <- sub('^ ', '', codebook$description)
```

**4. Add a column called `dataset`: a factor with the value `skeleton` or `footprint`, depending on the file that is referred to.**

```{r results = 'hide'}
codebook$dataset <- c(rep('skeleton', 18), rep('footprint', 11))
```

#### Write a utility function

```{r}
get_description <- function(column_name, dataset = 'skeleton') {
    if (! is.element(dataset, codebook$dataset)) {
        stop(paste0('dataset ', dataset, ' does not exist'))
    }
    if (! is.element(column_name, codebook$variable)) {
        stop(paste0('column ', column_name, ' does not exist'))
    }
    ##return the value
    codebook[codebook$dataset == dataset & codebook$variable == column_name, "description"]
}
get_description('Dinosaur_gen', 'skeleton')
```

#### Load skeleton data

```{r results = 'hide'}
skeleton_file <- "data/dinos/skeletons.csv"

(skeleton <- read.table(skeleton_file, 
                        sep = ";",
                        header = TRUE,
                        dec = ",",
                        as.is = 1))
```


#### Plot species versus time

Note the use of the utility function previously created, `get_description()`.

```{r species-vs-time, fig.asp=0.7, out.width='80%', fig.align='center', fig.cap="A first visualization"}
ggplot(data = skeleton,
       mapping = aes(x = Midpoint, y = log2(Total_spec))) +
    geom_point(aes(color = Epoch)) + 
    geom_smooth(method = "loess") +
    xlab(get_description("Midpoint")) +
    ylab(paste0("log2 of ", get_description("Total_spec"))) +
    scale_x_reverse()
```

#### Reproducing the publication figure

**Part 1. calculate the proportions**

We have not yet dealt with `dplyr` so we'll use base R for this. Note that the column `Total_gen` already contains the sum of all tetrapods.

```{r}
skeleton$genera_proportion <- (skeleton$Dinosaur_gen / skeleton$Total_gen) * 100
skeleton$specimen_proportion <- (skeleton$Dinosaur_spec / skeleton$Total_spec) * 100
```

**Part 2. calculate the mean of the proportions**

```{r results = 'hide'}
skeleton_proportions <- aggregate(
    cbind(genera_proportion, specimen_proportion) ~ Epoch + Stage + Midpoint, 
    data = skeleton,
    FUN = mean)
```

**Part 3. flatten" the data**

```{r results = 'hide'}
skeleton_proportions_long <- pivot_longer(data = skeleton_proportions, 
             names_to = "level", 
             values_to = "Proportion", 
             cols = ends_with("_proportion"))
```

**Part 4. generate the plot**

First it needs to be flattened for use in ggplot2:

```{r plot-reprodiction1, fig.asp=0.7, out.width='80%', fig.align='center', fig.cap="A reproduction"}
ggplot(data = skeleton_proportions_long,
       mapping = aes(x = Midpoint, y = Proportion, color = level)) +
    geom_point() +
    scale_x_reverse() +
    scale_color_manual(values = c("blue", "red")) +
    xlab("Geological age (Myr)") +
    annotate("point", x = 231, y = 1, shape = 23, size = 5, fill = "goldenrod1") +
    annotate("text", x = 231, y = -3, label = "CPE")
```

**Part 5. Add the moving average**

Actually, this is not that simple to do with base R. What you want is a function that calculates the mean over a time period or over a fixed sequence of numbers. We'll take the mean over a sequence of 3 numbers. This could be a possible solution, using a `for` loop.

```{r}
rows <- nrow(skeleton_proportions)
moving_average_spec <- numeric(rows)
moving_average_gen <- numeric(rows)
n <- 2
## reversed traversal!
for (i in rows:1) {
    if (i >= rows - n) {
        series <- i:rows
    } else {
        series <- i:(i+n) ## beware of the parentheses!
    }
    moving_average_gen[i] <- mean(skeleton_proportions$genera_prop[series])
    moving_average_spec[i] <- mean(skeleton_proportions$specimen_prop[series])
}
##attach to the proportions dataframe
skeleton_proportions$specimen_moving_average <- moving_average_spec
skeleton_proportions$genera_moving_average <- moving_average_gen

#skeleton_proportions <- skeleton_proportions[, c(1:4, 6, 5, 7)] 

##recreate the long form with pivot_longer
skeleton_prop_avg_long <- pivot_longer(data = skeleton_proportions,
             cols = matches("_"),
             names_pattern = "(genera|specimen)_",
             values_to = c("proportion", "moving_average"),
             names_to = "level")
```

Finally, plot:

```{r plot-reprodiction2, fig.asp=0.7, out.width='80%', fig.align='center', fig.cap="A reproduction"}

ggplot(data = skeleton_prop_avg_long) +
    geom_point(mapping = aes(x = Midpoint, y = proportion, color = level)) +
    geom_line(mapping = aes(x = Midpoint, y = moving_average, color = level)) +
    scale_x_reverse() +
    scale_color_manual(values = c("blue", "red")) +
    xlab("Geological age (Myr)") +
    annotate("point", x = 231, y = 1, shape = 23, size = 5, fill = "goldenrod1") +
    annotate("text", x = 231, y = -3, label = "CPE")
```

**[THIS IS NOT CORRECT YET!!]**


#### Make a better figure

The Loess regression curve is a favorite of mine.

```{r plot-reprodiction3, fig.asp=0.7, out.width='80%', fig.align='center', fig.cap="A reproduction"}
ggplot(data = skeleton_prop_avg_long, 
       mapping = aes(x = Midpoint, y = proportion, color = level)) +
    geom_point() +
    geom_smooth(method = "loess", se = FALSE) +
    scale_x_reverse() +
    scale_color_manual(values = c("blue", "red")) +
    xlab("Geological age (Myr)") +
    annotate("point", x = 231, y = 1, shape = 23, size = 5, fill = "goldenrod1") +
    annotate("text", x = 231, y = -3, label = "CPE")
```

#### Use the size aesthetic

We need more data for this, the totals for each "Stage":

```{r}
## re-create mean proportions
skeleton_proportions <- aggregate(
    cbind(genera_proportion, specimen_proportion) ~ Epoch + Stage + Midpoint, 
    data = skeleton,
    FUN = mean)

## first sum the finds:
skeleton_totals <- aggregate(
    cbind(Total_gen, Total_spec) ~ Midpoint,
    data = skeleton,
    FUN = sum)
tmp <- names(skeleton_totals)
tmp[2] <- "genera_totals"
tmp[3] <- "specimen_totals"
names(skeleton_totals) <- tmp

## combine with proportions
skeleton_prop_and_totals <- merge(skeleton_proportions, skeleton_totals, by = "Midpoint")

## reshuffling is required for pivot_longer to work as expected!!!
skeleton_prop_and_totals <- skeleton_prop_and_totals[, c(1:4, 6, 5, 7)]

## re-create the long form with pivot_longer
(skeleton_prop_totals_long <- pivot_longer(
    data = skeleton_prop_and_totals,
    cols = matches("_"),
    names_pattern = "(genera|specimen)_",
    values_to = c("proportion", "totals"),
    names_to = "level"))
```

Now for the plot

```{r plot-reprodiction4, fig.asp=0.7, out.width='80%', fig.align='center', fig.cap="A reproduction"}
ggplot(data = skeleton_prop_totals_long, 
       mapping = aes(x = Midpoint, y = proportion, color = level, size = totals)) +
    geom_point() +
    geom_smooth(method = "loess", se = FALSE) +
    scale_x_reverse() +
    scale_color_manual(values = c("blue", "red")) +
    xlab("Geological age (Myr)") +
    annotate("point", x = 231, y = 1, shape = 23, size = 5, fill = "goldenrod1") +
    annotate("text", x = 231, y = -3, label = "CPE")
```

## `tidyr` and `dplyr`



